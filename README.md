# Монитор независимых движений цены ETHUSDT

## Обзор проекта

Этот проект реализует систему мониторинга в реальном времени для обнаружения независимых движений цены фьючерсного контракта ETHUSDT, исключая влияние изменений цены BTCUSDT. Система использует линейную регрессию для изоляции идиосинкратических движений ETH и выводит оповещения, когда эти движения превышают 1% за последние 60 минут.

Задача состоит из двух частей:
1. **Разработка методологии**: Определить и обосновать метод исключения влияния BTCUSDT на цены ETHUSDT.
2. **Программа мониторинга в реальном времени**: Приложение на Python, которое получает живые данные, вычисляет независимые движения и выводит оповещения в консоль.

Ключевые особенности:
- Данные в реальном времени через WebSocket Binance для минимальной задержки.
- Периодическая рекалибровка модели (каждые 24 часа) с использованием 60 дней исторических данных.
- Хранение данных в PostgreSQL для аудита и восстановления.
- Объектно-ориентированный дизайн (OOP) для удобства поддержки.
- Контейнеризация с Docker для простоты развертывания.
- Код соответствует стандартам PEP8, с покрытием тестами >75%.

## Методология анализа

### Выбранный метод: Линейная регрессия
Используем линейную регрессию для моделирования доходностей ETHUSDT как функции доходностей BTCUSDT, изолируя остаточную (независимую) компоненту.

**Формула**:
```
ETH_returns = beta * BTC_returns + epsilon
```
- **ETH_returns** и **BTC_returns**: Логарифмические доходности (log(текущая_цена / предыдущая_цена)) для стационарности и симметрии.
- **beta**: Коэффициент, измеряющий чувствительность ETH к движениям BTC.
- **epsilon (остатки)**: Независимое движение ETH, не объясняемое BTC.
- **Примечание**: Мы опускаем член alpha (пересечение), поскольку он незначителен на коротких (минутных) горизонтах и может внести смещение. Alpha представляет постоянную сверхдоходность, что нерелевантно для цели декомпозиции.

**Обоснование**:
- **Простота и интерпретируемость**: Линейная регрессия проста, эффективна в вычислениях и напрямую разлагает движения на систематические (обусловленные BTC) и идиосинкратические (специфические для ETH) части.
- **Финансовая релевантность**: Основано на моделях, где beta захватывает корреляцию с рынком, а epsilon — уникальный фактор.
- **Рассмотренные альтернативы**: Более сложные методы (например, ARIMA, GARCH) отклонены из-за избыточности для декомпозиции в реальном времени и высокой вычислительной стоимости. Регрессия достаточна для этой задачи.

### Выбранные параметры и обоснование
- **Окно исторических данных**: 60 дней данных с интервалом 5 минут для начального расчета beta.
  - **Обоснование**: Обеспечивает репрезентативную выборку для стабильной оценки beta без включения устаревших рыночных режимов. Более короткие окна (например, 30 дней) рискуют нестабильностью; более длинные (например, 90 дней) могут игнорировать недавние изменения.
- **Частота рекалибровки**: Обновление beta каждые 24 часа с использованием скользящего окна 60 дней.
  - **Обоснование**: Рынки эволюционируют (например, из-за новостей или изменений ликвидности). Ежедневные обновления балансируют стабильность и адаптивность без перегрузки CPU в реальном времени.
- **Таймфрейм для доходностей**: Агрегация по 1 минуте для мониторинга в реальном времени.
  - **Обоснование**: Соответствует 60-минутному окну оповещений, снижает шум по сравнению с данными на уровне тиков и обеспечивает O(1) сложность через deque для скользящих сумм.
- **Порог оповещения**: Абсолютное изменение 1% (0.01) в накопленной epsilon за 60 минут.
  - **Обоснование**: Как указано в задаче; представляет значимое независимое движение.
- **Источник данных**: API Binance (REST для истории, WebSocket для живых данных).
  - **Обоснование**: Надежный источник с низкой задержкой для данных по криптофьючерсам.

**Алгоритм в реальном времени**:
1. Инициализировать beta из исторических данных.
2. При каждом обновлении цены (через WebSocket):
   - Вычислить логарифмические доходности для BTC и ETH.
   - Рассчитать epsilon = ETH_return - (beta * BTC_return).
   - Обновить deque фиксированного размера (60 элементов) с epsilon, поддерживая скользящую сумму O(1).
3. Если |скользящая_сумма| >= 0.01, вывести оповещение в консоль.
4. Рекалибровать beta каждые 24 часа в фоновом режиме.

Это обеспечивает оптимальную алгоритмическую сложность (O(1) на обновление) и минимальную задержку.

## Структура проекта

```
eth_btc_decoupler/
├── docker-compose.yml          # Настройка Docker для PostgreSQL и приложения
├── Dockerfile                  # Сборка образа Python-приложения
├── pyproject.toml              # Зависимости, управляемые через Poetry
├── .env.example                # Шаблон переменных окружения
├── README.md                   # Этот файл
├── .pre-commit-config.yaml     # Хуки для качества кода (black, isort, flake8, mypy)
├── tests/                      # Юнит- и интеграционные тесты (pytest)
│   ├── test_model.py           # Тесты для модели
│   ├── test_database.py        # Тесты для базы данных
│   ├── test_datafetcher.py     # Тесты для сборки данных
│   ├── test_monitor.py         # Тесты монитора
│   └── test_project.py         # Тесты интеграционных функций
├── scripts/                    # Утилитарные скрипты
│   ├── dev_test_monitor.py     # Ручной тест для монитора
│   ├── dev_test_integration.py # Скрипт интеграционного теста
│   ├── dev_set_db.py           # Скрипт для создания таблиц в базе данных
│   └── dev_init.py             # Ручная инициализация модели
└── src/
    ├── __init__.py
    ├── main.py                 # Точка входа: Оркестрация мониторинга
    ├── config.py               # Конфигурация (настройки БД, параметры алгоритма)
    ├── database/
    │   ├── __init__.py
    │   ├── models.py           # Определения таблиц SQLAlchemy
    │   └── crud.py             # Операции CRUD для БД
    ├── data_fetcher.py         # Клиент API/WebSocket Binance
    ├── model.py                # Расчет beta и функций доходностей
    ├── monitor.py              # Логика мониторинга остатков в реальном времени
    └── initialize.py           # Скрипт инициализации модели
```

- **Подход OOP**: Классы вроде `ResidualMonitor`, `BinanceDataFetcher`, `DatabaseManager` инкапсулируют логику для модульности.
- **Использование БД**: PostgreSQL хранит сырые цены (для истории) и beta (для восстановления). SQLAlchemy с asyncpg обеспечивает неблокирующий ввод/вывод.
- **Оптимизация**: Deque для скользящего окна O(1); асинхронные операции для задержки; пакетные/периодические записи в БД.

## Технические требования и качество
- **Версия Python**: 3.11 или выше.
- **Зависимости**: Управляются через Poetry (см. pyproject.toml). Ключевые библиотеки: aiohttp, websockets, pandas, scipy, sqlalchemy[asyncio], asyncpg, pytest.
- **Качество кода**: Соответствует PEP8.
- **Тестирование**: Покрытие >75% через pytest-cov. Включает юнит-тесты (функции/классы) и интеграционные тесты (полный пайплайн).
- **Git-репозиторий**: Весь код в удаленном Git-репозитории.

## Инструкции по установке

### Предварительные требования
- Python 3.11 или выше
- PostgreSQL (локально или через Docker)
- Docker и Docker Compose
- Доступ к API Binance (опционально для тестирования; ключи не нужны для публичных потоков)

### Пошаговая настройка
1. **Клонировать репозиторий**:
   ```
   git clone https://github.com/Hiro037/First-ML-Project.git
   cd First-ML-Project
   ```

2. **Установить зависимости** (через Poetry):
   ```
   poetry install
   ```

   Или через pip (если без Poetry):
   ```
   pip install -r requirements.txt  # Сгенерировать из Poetry, если нужно: poetry export -f requirements.txt --output requirements.txt
   ```

3. **Установить переменные окружения** (в `.env` или через export):
   ```
    # Настройки Базы Данных
    DATABASE_NAME="your_db_name"
    DATABASE_USER="your_user"
    DATABASE_PASSWORD="your_password"         # ЗАМЕНИТЕ на свой надежный пароль
    DATABASE_HOST="localhost"                 # Для локальной разработки
    DATABASE_PORT=5432

    # Время перерасчета модели (в секундах)
    BETA_RECALCULATION_INTERVAL="86400"       # 24 часа = 60*60*24

    # Параметры алгоритма
    PRICE_CHANGE_THRESHOLD="0.01"             # 1%
    LOOKBACK_WINDOW_MINUTES="60"              # 60 минут
    ```

4. **Запустить PostgreSQL через Docker**:
   ```
   docker-compose up -d db
   ```

5. **Инициализировать таблицы БД** (запустить один раз):
   Используйте скрипт `dev_set_db.py` или вручную подключитесь и выполните `metadata.create_all()` из `models.py`.

### Полная настройка через Docker
- Собрать и запустить все приложение:
  ```
  docker-compose build
  docker-compose up -d
  ```

## Инструкции по запуску

1. **Запустить мониторинг в реальном времени**:
   ```
   poetry run python -m src.main
   ```
   - Проект автоматически будет инициализирован.
   - База данных будет автоматически настроена (при первом запуске).
   - Выводит оповещения в консоль при движениях >1%.
   - Работает бесконечно; остановить через Ctrl+C.

2. **Запустить тесты**:
   ```
   poetry run pytest tests/ --cov=src
   ```
   - Обеспечивает покрытие >75%.

## Устранение неисправностей
- **Beta не найден**: Сначала запустите инициализацию.
- **Проблемы с WebSocket**: Проверьте сеть; Binance может иметь лимиты.
- **Ошибки подключения к БД**: Проверьте DATABASE_URL и запуск PostgreSQL.
- **Задержка**: WebSocket обеспечивает <1с задержку; проверьте логи на проблемы.

По вопросам обращайтесь к комментариям в коде или к разработчику.